name: 'formatting'
description: 'CI formatting check'
inputs:
  path:
    description: 'Path to repository folder to run formatting check for.'
    required: false
    default: ./
  exclude-files:
    description: 'List of comma-separated files to exclude from formatting check. Eg file1, file2'
    required: false
  exclude-dirs:
    description: 'List of comma-separated directories to exclude from formatting check. Eg docs, build'
    required: false
  include-extensions:
    description: 'List of comma-separated extensions to add to the formatting check. Eg md, dox'
    required: false

runs:
  using: "composite"
  steps:
      - env:
          bashPass: \033[32;1mPASSED -
          bashInfo: \033[33;1mINFO -
          bashFail: \033[31;1mFAILED -
          bashEnd:  \033[0m
          stepName: Install Uncrustify
        shell: bash
        run: |
          # ${{ env.stepName }}
          echo -e "::group::${{ env.stepName }}"
          sudo apt-get install uncrustify fd-find dos2unix
          echo -e "::endgroup::"

      - env:
          bashPass: \033[32;1mPASSED -
          bashInfo: \033[33;1mINFO -
          bashFail: \033[31;1mFAILED -
          bashEnd:  \033[0m
          stepName: Run Uncrustify
        name: ${{ env.stepName }}
        id: action-formatting-check
        working-directory: ${{ inputs.path }}
        shell: bash
        run: |
          # ${{ env.stepName }}
          echo -e "${{ env.bashInfo }} Using Uncrustify Version "$(uncrustify --version)" ${{ env.bashEnd }}"

          # Parse the optional inputs
          args=""

          # fd-find uses -E to exclude a file or directory
          if [ -n "${{ inputs.exclude-dirs }}" ]; then
            dirs=" -E "
            dirs+="${{ inputs.exclude-dirs }}"
            dirs="${dirs//,/ -E }"
            args+=" ${dirs}"
          fi

          # fd-find uses -E to exclude a file or directory
          if [ -n "${{ inputs.exclude-files }}" ]; then
            files=" -E "
            files+="${{ inputs.exclude-files }}"
            files="${files//,/ -E }"
            args+=" ${files}"
          fi

          # fd-find uses -e to include a file extension
          if [ -n "${{ inputs.include-file-types }}" ]; then
            file_types=" -e "
            file_types+="${{ inputs.include-file-types }}"
            file_types="${file_types//,/ -e }"
            args+=" ${file_types}"
          fi

          # Get all .c and .h files, as well as any other requested file types.
          # Then run uncrustify with the common config file.
          echo -e "${{ env.bashInfo }} Running: fdfind -e c -e h ${args} --exec uncrustify --no-backup --replace --if-changed -c $GITHUB_ACTION_PATH/uncrustify.cfg -l C ${{ env.bashEnd }}"
          echo -e "::group::${{ env.bashInfo }} Check Formatting with Uncrustify ${{ env.bashEnd }}"
          fdfind -e c -e h ${args} --exec uncrustify --no-backup --replace --if-changed -c $GITHUB_ACTION_PATH/uncrustify.cfg -l C
          echo -e "::endgroup::"

          echo -e "::group::${{ env.bashInfo }} Check for Trailing Whitespace ${{ env.bashEnd }}"
          # These checks will be captured in the git diff
          # Replace all trailing whitespace, exclude photo files and args
          fdfind --type=file -E '*.png' -E '*.jpg' -E '*.svg' ${args} . --exec sed -Ei 's/[[:blank:]]+$//'
          echo -e "::endgroup::"

          echo -e "::group::${{ env.bashInfo }} Check for CRLF Line Endings ${{ env.bashEnd }}"
          # Replace all line endings with LF ones instead of CRLF
          fdfind --type=file ${args} . --exec dos2unix
          echo -e "::endgroup::"

          # Run a git diff to print the differences if any exist, return an error code if there are any
          # Wrap in a set+e and set -e so we can keep running after the error
          echo -e "::group::${{ env.bashInfo }} Format Difference ${{ env.bashEnd }}"
          set +e
          git diff --exit-code --color=always
          exitCode=$?
          set -e
          echo -e "::endgroup::"

          if [ $exitCode -eq 0 ]; then
            echo -e "${{ env.bashPass }} ${{ env.stepName }} ${{ env.bashEnd }}"
          else
            # I am intentionally doing this a second time here.
            # Using tee will mask the exit code of the diff
            # And we don't want the colour to be added to the patch
            # Put it in what the 'default' path will be for the upload step
            git diff > formattingChanges.patch
            echo -e "${{ env.bashFail }} List of files with formatting errors: ${{ env.bashEnd }}"
            echo -e "${{ env.bashFail }} "$(git diff --name-only)" ${{ env.bashEnd }} "
            echo -e "${{ env.bashFail }} ${{ env.stepName }} ${{ env.bashEnd }}"
          fi
          exit $exitCode

      - name: Upload Formatting Git Patch
        if: failure() && ( steps.action-formatting-check.outcome == 'failure' )
        id: upload-formatting-patch
        uses: actions/upload-artifact@v3
        with:
          name: formattingChanges
          path: ${{ inputs.path }}/formattingChanges.patch
          retention-days: 7

      - env:
          stepName: Formatting Git Patch Info
          bashPass: \033[32;1m
          bashInfo: \033[33;1m
          bashFail: \033[31;1m
          bashEnd:  \033[0
        if: failure() && ( steps.upload-formatting-patch.outcome == 'success' )
        shell: bash
        run: |
          # ${{ env.stepName }}
          echo -e "${{ env.bashInfo }} A git patch of the formatting issues has been attached to this workflow ${{ env.bashEnd }}"
          echo -e "${{ env.bashInfo }} This can be accessed by returning to the bottom of the summary page of the workflow run ${{ env.bashEnd }}"
          echo -e "${{ env.bashInfo }} At the bottom of the page will be a formattingChanges.patch file that you can download ${{ env.bashEnd }}"
          echo -e "${{ env.bashInfo }} Copy this patch to your repository and apply it using 'git apply formattingChanges.patch' ${{ env.bashEnd }}"
