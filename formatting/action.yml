name: 'formatting'
description: 'CI formatting check'
inputs:
  path:
    description: 'Path to repository folder to run formatting check for.'
    required: false
    default: ./
  exclude-files:
    description: 'List of comma-separated files to exclude from trailing whitespace check. Eg file1,file2'
    required: false
    default: ''
  exclude-dirs:
    description: 'List of comma-separated directories to exclude from trailing whitespace formatting check. Eg docs,build'
    required: false
    default: ''
runs:
  using: "composite"
  steps:
      - name: Install Uncrustify
        run: |
          : # Install Uncrustify
          echo "::group::Install Uncrustify"
          sudo apt-get install uncrustify
          echo "::endgroup::"
        shell: bash

      - env:
          stepName: Validate Inputs
          # The bash escape character is \033
          # At time of writing, you can't add a global environment
          # to an action file so stuck with this. If this gets changed
          # Please move this
          bashPass:   \033[32;1mPASSED -
          bashWarn:   \033[33;1mINFO -
          bashFail:   \033[31;1mFAILED -
          bashEnd:    \033[0m
        name: ${{ env.stepName }}
        id: compile-executable-monitor-test-files
        shell: bash
        run: |
          # ${{ env.stepName }}
          set +e
          exitStatus=0
          # Check exclude dirs for possible input issues
          if [[ "${{ inputs.exclude-dirs }}" = *" "* ]]; then
            echo -e "${{ env.bashFAIL }} YOU HAVE WHITESPACE IN YOUR EXCLUDE-DIRS. ${{ env.bashEnd }}"
            exitStatus=1
          fi

          # Check exclude-files  for possible input issues
          if [[ "${{ inputs.exclude-files }}" = *" "* ]]; then
            echo -e "${{ env.bashFail }} YOU HAVE WHITESPACE IN YOUR EXCLUDE-FILES. ${{ env.bashEnd }}"
            exitStatus=1
          fi
          set -e
          exit $exitStatus

      - env:
          stepName: Run Uncrustify
        name: ${{ env.stepName }}
        working-directory: ${{ inputs.path }}
        shell: bash
        run: |
          # Uncrustify on C files while ignoring symlinks.
          echo "::group::Uncrustify Check"

          # GitHub automatically use "set -e" which causes scripts to fail on the first exit code
          # This would mean the first time a file fails the check that we exit without formatting all files.
          set +e
          set -v

          # Break the option out of the glob
          # Doing something like:
          # excludeDirs=$(echo ${{inputs.exclude-dirs}} | sed 's/ //g')
          # excludeFiles=$(echo ${{inputs.exclude-files}} | sed 's/ //g')
          # To remove potential spaces doesn't
          for file in ${{inputs.exclude-files}}; do
            exclude-file="$exclude-file --exclude-file=$file"
          done

          for dir in ${{inputs.exclude-dirs}}; do
            exclude-dirs="$exclude-dirs --exclude-dir=$dir"
          done

          # Get all files that end in .c or .h. Exclude any files or directories that we were asked to.
          # Then limit the search to files that have the amazon copyright on them.
          set -x
          files=$(grep --include={*.[ch],} --exclude={${{inputs.exclude-files}},} --exclude-dir={${{inputs.exclude-dirs}},} -lrniE "copyright (.*) [0-9]{4} amazon.com" )

          # Loop over the files that matched the above conditions
          for file in ${files[@]}; do
            # Print them out for future debugging
            echo -e "${{ env.bashWarn }}Parsing File:$file ${{ env.bashEnd }}

            # Pipe the output of the command to a variable
            # This way we can print the command only if it fails
            fileOut=$(uncrustify --no-backup --replace --if-changed -c $GITHUB_ACTION_PATH/uncrustify.cfg -l C $file 2>&1)

            # If the previous command failed then print out an error message as well as the output
            if [ "$?" != "0" ]; then
              # On an error print out the message
              echo -e "${{ env.bashFail }}Error parsing $file:\n${{ env.bashEnd }}"
              echo -e "$fileOut"
            fi
          done

          echo "::endgroup::"
          # Run a git diff to print the differences if any exist, return an error code if there are any
          git diff --exit-code
          if [ "$?" = "0" ]; then
            echo -e "${{ env.bashPass }}Uncrustify check passed${{ env.bashEnd }}"
          else
            filesWithErrors=$(git diff --name-only)
            echo -e "${{ env.bashFail }}List of files with formatting errors:$filesWithErrors${{ env.bashEnd }}"
            echo -e "${{ env.bashFail }}Formatting check (using Uncrustify) failed...${{ env.bashEnd }}"
            # If there is an error, set this flag high again so the exit 1 fails the run instantly
            set -e
            exit 1
          fi

      - env:
          stepName: Check For Trailing Whitespace
        name: ${{ env.stepName }}
        shell: bash
        # Use this so that even if we fail formatting these checks run
        # Solves the issue of "Make commit to fix formatting, to then learn
        # You need to fix whitespace
        if: success() || failure()
        working-directory: ${{ inputs.path }}
        run: |
          # ${{ env.stepName }}
          set +e
          set -x
          # Strip all the whitespace from the inputs
          # Yes this breaks the ability to have files/directories with spaces.
          # But that breaks most UNIX commands. Including the following grep glob.
          excludeFiles=$(echo ${{inputs.exclude-files}} | sed 's/ //g')
          excludeDirs=$(echo ${{inputs.exclude-dirs}} | sed 's/ //g')
          grep --exclude={README.md,${{inputs.exclude-files}},} --exclude-dir={${{inputs.exclude-dirs}},.git} -rnIe "[[:blank:]]$" .
          if [ "$?" = "0" ]; then
            set -e
            echo -e "${{ env.bashFail }} ${{ env.stepName }} ${{ env.bashEnd }}"
            exit 1
          else
            echo -e "${{ env.bashPass }} ${{ env.stepName }} ${{ env.bashEnd }}"
            exit 0
          fi

      - env:
          stepName: Check for CRLF
        name: ${{ env.stepName }}
        if: success() || failure()
        working-directory: ${{ inputs.path }}
        shell: bash
        run: |
          # ${{ env.stepName }}
          set +e
          set -x
          # Strip all the whitespace from the inputs
          # Yes this breaks the ability to have files/directories with spaces.
          # But that breaks most UNIX commands. Including the following grep glob.
          excludeFiles=$(echo ${{inputs.exclude-files}} | sed 's/ //g')
          excludeDirs=$(echo ${{inputs.exclude-dirs}} | sed 's/ //g')
          grep --exclude={${{inputs.exclude-files}},} --exclude-dir={${{inputs.exclude-dirs}},.git} -rnl $'\r'
          if [ "$?" = "0" ]; then
            set -e
            echo -e "${{ env.bashFail }} ${{ env.stepName }} ${{ env.bashEnd }}"
            exit 1
          else
            echo -e "${{ env.bashPass }} ${{ env.stepName }} ${{ env.bashEnd }}"
            exit 0
          fi
